import { Story, Preview, Meta, Props } from '@storybook/addon-docs/blocks';

<Meta title="框架|混入器（Mixin）/表单记录器（第二版-废弃）" />

# 表单记录器（新版）

> 注意： 本表单记录器为新版的，相对以前的可以支持动态表单设定。

该混入器可以很方便的为`ant-design-vue`表单添加数据记录，减少开发人员的配置。

表单记录器是一个函数，他能为当前表单自动生成可用的表单`form`和记录数据`record`，但这需要你额外但增加两个参数。

表单记录器参数：

- formName - 一个表单的名称，这个名称是你用来配置到`<a-form :form="form"></a-form>`中的变量名称，该变量会直接挂到`data`数据中，你可以直接使用`this[formName]`很方便的得到他。需要注意的是，`form`永远和`record`一一对应，你成功配置了`formName`，也就会自动生成名为`${formName}Record`的数据`record`。
- fields - 绑定的数据字段集合。如果配置为`void 0`类型，则表示绑定`record`下的所有字段。

例如，你使用`mixins: [formRecordMix('issueForm', ['code', 'name'])]`混入了这个表单记录器，那么你可以使用如下的公开对象：

- issueForm(只读) - 表单；
- issueFormRecord(可读写) - 表单数据记录

## 使用方法

下面我们看一个完整的案例（**.vue**文件中混入）：

```html
<template>
  <!-- 1. 在视图中直接引入`form`变量 -->
  <a-form
    :form="form"
  >
    <!-- ... -->
  </a-form>
</template>
<script>
// 2. 引入混入器 （注意： 这里是新版的表单记录器 ）
import formRecordMix from '@mix/form-record-mix.js';
// ...
export default {
  // 3. 混入分页器，生成名为`form`和`formRecord`两个数据，默认绑定`formRecord`所有字段
  mixins: [ formRecordMix('form') ],
  // ...
  created () {
    this.fetch().then(res => {
      // ...
      // 4. 初始化表单值，或者不这么做也可以
      this.formRecord = { ...res };
      // ...
    });
  },
  // ...
}
</script>
```

> 注意：
>
> 1. 你可以在自己的组件中通过`data`函数初始化`formRecord`，填写需要初始化的数据信息，用于显示默认值；也可以在`mounted`之前给`formRecord`赋上初始值用于回显。
> 2. `formRecordMix('form')`生成的`formRecord`将具备双向绑定特性，会自动和`form`数据自动更新。

## 额外方法

另外，我们为这里的`form`额外增加了几个方法：

- form.reset() - 将表单记录重置为最初始状态，这个方法有别于`ant-design-vue`所提供的`resetFields`，他是一个更新的方法，当你使用`vsee`框架时，应该只用`reset`方法即可，这会给你节省更多的时间。
- form.clear() - 真正的将表单数据全部清空的方法，所有数据都会变为`void 0`，注意不是`null`值，因为`void 0`是表单可识别的初始值。在面对提交数据时，需要注意`void 0`是不会被提交的。
- form.set(record, cached) - 设置`formRecord`的值，第一个参数是`formRecord`的修改部分，第二个参数是**是否缓存当前formRecord**。
- form.update(newRecord, cached) - 将`formRecord`的值替换为新值，第一个参数是替换值，第二个参数是**是否缓存当前formRecord**。

下面给出一个动态表单的案例：

```html
<template>
  <a-form
    :form="form"
  >
    <template>
      <!-- 直接遍历`formRecord.names`属性，该属性表明为动态属性 -->
      <a-form-item
        v-for="(key, index) in formRecord.names"
        :key="index"
        :label="`相关联络人`"
      >
        <a-icon
          type="plus"
          @click="() => add(formRecord.names, 0)"
        />
        <a-input
          v-decorator="[`names[${index}]`, {}]"
        />
        <a-icon
          type="plus"
          @click="() => add(formRecord.names, index + 1)"
        />
        <a-icon
          v-if="index"
          type="minus-circle"
          @click="() => remove(formRecord.names, index)"
        />
      </a-form-item>
      <a-form-item
        label="checkbox数组"
      >
        <a-checkbox-group
          v-decorator="[`checkbox`, {}]"
          :options="checkboxOptions"
        />
      </a-form-item>
      <a-form-item label="日期范围">
        <a-range-picker
          v-decorator="[`dataRange`, {}]"
        />
      </a-form-item>
      <a-form-item
        :label="'字符串'"
      >
        <a-input
          v-decorator="[`str`, {}]"
        />
      </a-form-item>
    </template>
    <a-button @click="reset">
      重置
    </a-button>
    <a-button @click="clear">
      清空
    </a-button>
  </a-form>
</template>

<script>
// 引入新版的`表单记录器`
import formRecordMix from '@mix/form-record-mix.js';

export default {
  mixins: [formRecordMix('form')],
  data () {
    return {
      checkboxOptions: ['Apple', 'Pear', 'Orange'],
      formRecord: {
        checkbox: ['Apple'],
      },
    };
  },
  created () {
    /**
     * 如果你直接使用如下代码：
     * this.formRecord = { names: ['张三', '李四'], str: '123' };
     * 无论是在异步请求还是在同步请求中，该值都不会被记录到缓存，还原时，只会`reset`到`data`的状态。
     */
    
    // this.form.set({ names: ['床前明月光'], str: '123' }, true);
    setTimeout((res) => {
      /**
       * 如果你直接使用如下代码：
       * this.form.set(res, true);
       * 那么`res`会合并到`data.formRecord`中，并将合并后的`formRecord`作为缓存值记录下来,
       * 此时再进行`reset`时，会将合并后的`formRecord`提取出来。
       */
      /**
       * 如果你直接使用如下代码：
       * this.form.update(res, true);
       * 那么`res`会全部替换到`data.formRecord`中，并将替换后的`formRecord`作为缓存值记录下来,
       * 此时再进行`reset`时，会将替换后的`formRecord`提取出来。
       */
      this.form.update(res, true);
    }, 800, { names: ['张三', '李四'], str: '测试字符串' });
  },
  methods: {
    reset () {
      // 调用该方法后，表单会重置为最开始状态，该状态可以由开发者在`data.formRecord`中设置，也可以使用`this.form.set`或者`this.form.update`进行手动缓存
      this.form.reset();
    },
    clear () {
      // 调用该方法后，表单的所有值都设置为空
      this.form.clear();
    },
    remove (list = [], index) {
      // 移除动态数据项
      list.splice(index, 1);
    },
    add (list = [], index) {
      // 增加动态数据项
      list.splice(index, 0, '');
    },
  },
};
</script>

```
