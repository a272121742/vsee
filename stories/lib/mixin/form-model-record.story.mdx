import { Story, Preview, Meta, Props } from '@storybook/addon-docs/blocks';

<Meta title="框架/混入器（Mixin）/表单记录器（新版）" />

# 表单记录器

> 添加版本： @vsee/1.1.41
>
> 维护记录：
>
>| 版本        | 更新说明 | 更新时间 |
>| ---------- | -------- | -------- |
>|   1.1.41   |    新增      |     2020年06月16日     |
>|   1.1.42   | 1.重构表单验证<br/> 2.修复reset方法失效的bug | 2020年07月03日 |
>

该混入器可以很方便的为`ant-design-vue`表单添加数据记录，减少开发人员的配置。

表单记录器是一个函数，他能为当前表单自动生成可用的表单记录数据`record`，并帮你缓存表单的组件内存。

表单记录器（formModelRecordMix）参数是一个大对象，包含如下键：

- record - `record`的名称，默认值即为`record`，此选项帮你生成一个记录器对象，记录器对象设有`clear`、`reset`、`set`、`cache`等方法，因此它即是一个双向绑定的对象（ViewModel），同时又是一个可操作的对象（Record）。
- form - '$refs'的简写，默认值为`form`。此选项并不是自动生成一个表单视图，而是你定义的`ref`的一个简写。你应当正确的设置该值，并避免被占用。
- map - 一个表单的映射函数，绑定`record`自身作为上下文且无返回的函数，你可以在`record`被设置前去修改它，让生成的`record`具备和`a-form-model`匹配的数据格式。后面会具体讲到它的用法和最佳实践。

## 使用方法

下面我们看一个完整的案例（**.vue**文件中混入，或[点击这里查看](http://106.75.63.69:8091/tqis/form?key=BindRecord)）：

```html
<template>
  <!-- 1. 在视图中绑定`record`对象， `:model="record"`就是让表单实体绑定到`record`上 -->
  <a-form-model
    ref="form"
    :model="record"
  >
    <!-- ... -->
  </a-form-model>
</template>
<script>
// 2. 引入混入器
import formModelRecordMix from '@mix/form-model-record.js';
// ...
export default {
  // 3. 混入分页器，生成名为`form`和`formRecord`两个数据，默认绑定`formRecord`所有字段
  mixins: [ formRecordMix({
    // 3.1 定义`record`的名称，默认值即为`record`，如果没有特殊冲突，可不设定以用默认值
    // record: 'record',
    // 3.2 告知混入器form的引用名称，默认为`form`，即上面`ref="form"`所给定的名称，它的作用仅仅是帮你生成一个`computed`属性，用`this.form`来替代`this.$refs.form`；
    // form: 'form',
    // 3.3 设值映射函数，该函数在设置`record`最终值时会自动使用，其上下文就是`record`自身，因此你绝对不能使用箭头函数。
    map: function () {
      this.xxx = 'xxx';
    }
  }) ],
  // ...
  created () {
    this.fetch().then(res => {
      // ...
      // 4. 初始化表单值，或者不这么做也可以
      this.record.load({ ...res });
      // 或者使用
      // this.record.set({ ...res });
      // ...
    });
  },
  methods: {
    // 重置数据
    reset () {
      this.record.reset();
    },
    // 清空数据
    clear () {
      this.record.clear();
    },
    // 缓存数据
    cache () {
      this.record.cache();
    },
  }
  // ...
}
</script>
```

## Record对象接口

### cache([fields])

缓存相关属性，或按照给定字段`fields`进行缓存；该方法为`reset`方法提供可供还原的缓存（后面讲解），需要注意的是：

1. 是否缓存字段是一个业务问题，而并非组件问题，因为组件并不清楚这样的设置会有多少次，所以开发者需要手动进行缓存；
2. 缓存是单向的，它并不记录之前的缓存，也无法获取之前的缓存，而仅仅是即存即取的；
3. `set`和`load`方法中有便捷缓存配置（后面讲解）；

### set(values[, cacheIt])

设置`record`，该方法只会设置`values`给定的键：

1. 如果设置前`record`不包含`values`的键，则内部会通过`$set`方式设置，以确保设置后该属性是`observer`的；
2. 如果设置前`record`包含`values`的键，则内部会直接通过对象赋值方式进行设置；
3. 如果`values`对应键不包含在`record`中，则`record`是不会处理其他不包含的键，你可以人为它是局部更新的函数；
4. 如果配置了`cacheIt = true`（Boolean变量），则设置完后内部会调用`cache`函数对当前整个`record`进行缓存；

例如：

```javascript
// set方法调用前，record = {a: 'a', b: 'b', c: 'c'};
this.record.set({c: 'c2', d: 'd2'}, true);
// 调用后， record = {a: 'a', b: 'b', c: 'c2', d: 'd2'}，且该值会被缓存下来
```

### load(values[, cacheIt])

载入`record`，该方法会将`record`重置为`values`，该方法区别于`set`方法是，他会清除其他属性。

例如：

```javascript
// load方法调用前，record = {a: 'a', b: 'b', c: 'c'};
this.record.load({c: 'c2', d: 'd2'}, true);
// 调用后， record = {c: 'c2', d: 'd2'}，且该值会被缓存下来
```

### clear([fields])

清空相关属性，或按照给定字段`fields`进行清空；该方法会将所有已经绑定值设置为`null`（`null`值是为了保证数据可以提交，服务端接受到`null`后会做更新处理）；在回显时，这个方法也是安全的，它并不是单纯的将`record`设置为`{}`，而是将检测到的字段设置为`null`，当然在第一次提交时，它是可以将`record`设置为空对象的。

例如：

```javascript
// clear方法调用前，record = {a: 'a', b: 'b', c: 'c'};
this.record.clear();
// 调用后， record = {a: null, b: null, c: null}

// clear方法调用前，record = {a: 'a', b: 'b', c: 'c'};
this.record.clear(['a', 'b']);
// 调用后， record = {a: null, b: null, c: 'c'}
```

### reset([fields])

重置相关属性，或按照给定字段`fields`进行重置；该方法区别于`clear`，会根据`cache`缓存进行还原，而不是重置为空对象或全部属性设置为`null`。

例如： 

```javascript
// reset方法调用前，record = {a: 'a', b: 'b', c: 'c'};
this.record.load({a: 'a', b: 'b', c: 'c'}, true);
this.record.set({a: 'a2'});
this.record.reset();
// 调用后， record =  {a: 'a', b: 'b', c: 'c'}

// reset方法调用前，record = {a: 'a', b: 'b', c: 'c'};
this.record.load({a: 'a', b: 'b', c: 'c'}, true);
this.record.set({a: 'a2', b: 'b2', c: 'c2'});
this.record.reset(['a']);
// 调用后， record =  {a: 'a', b: 'b2', c: 'c2'}
```

> 注意: 无论是`clear`、`reset`方法还是`set`、`load`方法，都无法清除或者重置`form`的验证信息。如果表单的视图已经做了验证并出现了验证信息，仅仅是清理数据`record`是不管用的，你还需要手动去清理`form`的UI验证显示，参考[官方文档](https://www.antdv.com/components/form-model-cn/#%E6%96%B9%E6%B3%95)调用`this.form.clearValidate`方法即可。

### valueOf([mapping])

获取`record`的转换值。一般情况下直接使用`record`是具备引用关系传递的，为了断开原始连接，我们更加建议你使用`valueOf`方法。不仅能断开连接，还能使用`mapping`函数直接转换成欲提交的值（后面讲解）。

## 映射

我们将表单分离出了UI模型和数据模型（form/record），`form`主要负责视图展示和验证，`record`就负责绑定值。但真实的业务中，`record`和`form`所需要的期望值是不一致的，`record`和提交值也不一致。这就需要进行数据映射来方便开发者自动对这些值进行转换。在这个处理过程中，我们更加推荐使用`seq`组合子来完成，代码看起来会更加的简洁优秀。

[查看案例可点击这里](http://106.75.63.69:8091/tqis/form?key=MapRecord)

### 赋值映射

以时间为例，服务端返回的时间格式为`String`，但是UI组件中需要的数据类型为`Moment`。开发者需要手动去进行处理，他会遇到两个问题：

1. 处理的过程重用率太低，在各处都要显示的去写处理代码；
2. 某些属性是组合属性，合并或拆开后需要删掉原始属性；

例如：

```javascript
import formRecord, { map2Moment, zip2MomentRange, deleteField } from '@mix/form-model-record.js';
import { seq } from '@util/fnhelper.js';

// 赋值映射
const recordMapForm = seq(
  // 将createTime，转换成Moment格式
  map2Moment('createTime'),
  // 将（breakTimeStart, breakTimeEnd）合并成breakTime的Moment数组格式
  zip2MomentRange('breakTime'),
  // 删除`breakTimeStart`、`breakTimeEnd`字段
  deleteField(['breakTimeStart', 'breakTimeEnd']),
);

export default {
  mixins: [
    formRecord({
      map: recordMapForm,
    }),
  ],
  created: {
    this.record.load({
      // 原始值`createTime`从服务端获取的是一个字符串，会自动映射成`Moment`类型设置到`form`视图中
      createTime: '2019-6-6',  // => { createTime: [Moment]}
      // 原始值`breakTimeStart`和`breakTimeEnd`是从其他页面跳转传递过来的，会自动组合成`breakTime`，它是一个`Moment`数组格式
      breakTimeStart: '2019-01-01',  // => { breakTime: [Moment, Moment]}
      breakTimeEnd: '2020-12-31',
    });
  }
}
```

并且，当你使用`load`和`set`方法时，也会自动做赋值映射处理。

### 取值映射

反之，当想要把值提交到服务端，或者传递给其他页面或组件时，我们也可以进行取值映射。它的定义形式和**赋值映射**完全一致，你可以人为它是一个逆运算。

例如：

```javascript
import formRecord, { map2Datetime, split2DatetimeRange, deleteField } from '@mix/form-model-record.js';
import { seq } from '@util/fnhelper.js';

// 提交映射
const recordMapTo = seq(
  // 将`createTime`转换成Datetime的字符串
  map2Datetime('createTime'),
  // 切割`breakTime`为两个Datetime字段，分别是`breakTimeStart`、`breakTimeEnd`
  split2DatetimeRange('breakTime'),
  // 删除`breakTime`字段
  deleteField('breakTime'),
);
export default {
  methods: {
    commit () {
      // record = { createTime: Moment('2019-06-06'), breakTime: [Moment('2019-01-01'), Moment('2020-12-31')]}
      const commitValue = this.record.valueOf(recordMapTo);
      // commitValue = { createTime: '2019-06-06 00:00:00', breakTimeStart: '2019-01-01 00:00:00', breakTimeEnd: '2020-12-31 00:00:00'}
      // this.record.valueOf() = { createTime: Moment('2019-06-06'), breakTime: [Moment('2019-01-01'), Moment('2020-12-31')]}, 它和this.record值保持一致，但断开了引用连接。
    }
  }
}
```

## 转换函数

从上面的映射的例子可以看到，`form-model-record.js`中内置了一些转换函数，这些转换函数的格式都是：

```javascript
const mapFunction = (function (field) {
  return (function (record) {
    // this === record
    // 可直接对`record`进行修改
    // 该函数是无返回值的
  }).bind(this)
}).bind(record);
```

因此，熟悉框架和函数式编程的可知，使用`seq`函数可以实现链式编程（案例见上面）。`form-model-record`内置定义的转换函数如下：

```javascript
// * -> Moment(*)
function map2Moment (field, record) {};
// * -> [Moment(*), Moment(*)]
function map2MomentRange (field, record) {};
// * -> { Start: Moment(*), End: Moment(*) }
function split2MomentRange (field, record) {};
// { Start: Moment(*), End: Moment(*) } -> [Moment(*), Moment(*)]
function zip2MomentRange (field, record) {};

// * -> DatetimeString(*)
function map2Datetime (field, record) {};
// * -> DateString(*)
function map2Date (field, record) {};
// * -> TimeString(*)
function map2Time (field, record) {};
// * -> [DatetimeString(*), DatetimeString(*)]
function map2DatetimeRange (field, record) {};
// * -> { Start: DatetimeString(*), End:  DatetimeString(*) }
function split2DatetimeRange (field, record) {};
// { Start: DatetimeString(*), End:  DatetimeString(*) } -> [DatetimeString(*), DatetimeString(*)]
function zip2DatetimeRange (field, record) {};
// * -> Boolean(*)
function map2Boolean (field, record) {};
// 删除字段, `field`可为单个`field`，也可以为数组`fields`
function deleteField (field, record) {};
```

当然，你可以也可以自定义转换函数，例如，我们希望格式化字符串，你也应该参照上面`mapFunction`的方式去定义，但可以不用绑定上下文，因为绑定上下文是内部自动的。举一个简单的例子：

```javascript
import formRecord from '@mix/form-model-record.js';
import { seq } from '@util/fnhelper.js';

// 自定义映射，第一层是函数
const filedFormat = (field) => {
  // 第二层是返回一个函数
  return (record) => {
    // 第三层是修改上下文
    record[field] = record[field] + '%';
  };
}
// 注意，你不用去绑定上下文，上下文是由内部决定的，内部会自动进行绑定

// 提交映射
const recordMapTo = seq(
  // 将成功率转换成字符串
  filedFormat('successRate')
);
// 因此，传入的原值如果为`69`，则会自动转换为`69%`并设置到表单UI组件中.
```

> 注意： 今后如果有公共的需要添加的转换函数，会统计业务的特性追加，没有追加之前可以自行定义。

## 表单验证

表单验证属于`view`层面的事情，即`form`可执行的方法，`record`无法代理，因此，但我们不是提供了`form`配置么，如果你配置了，将可以使用省略的写法：

```html
<template>
  <!-- 这里的`ref`值必须和下面的`form`定义一致 -->
  <a-form-model
    ref="form"
    :model="record"
  >
    <!-- ... -->
  </a-form-model>
</template>
<script>
import formModelRecordMix from '@mix/form-model-record.js';
// ...
export default {
  mixins: [ formRecordMix({
    // 这里的`form`值必须和上面的`ref`定义一致，此时会生成一个`this.form`计算属性
    form: 'form',
  }) ],
  // ...
  methods: {
    commit () {
      // 等价于 this.$refs.form.validate
      this.form.validate((valid) => {
        if (valid) {
          // 提交的业务逻辑
        }
        // 请注意，无论如何，都要返回这个，这个是为了提供给视图进行验证反馈的
        return valid;
      })
    }
  }
  // ...
}
</script>
```

下面通过列表列出所有的内部验证（[参考案例](http://106.75.63.69:8091/tqis/form?key=FormValidate)）：

### 字串验证

| 方法                      | 注入参数        | 功能说明                                                     |
| ------------------------- | --------------- | ------------------------------------------------------------ |
| maxLen(len, msg)          | {{max}}         | 字符串长度是否超出最大值，即`str.length <= max`，若超则返回验证消息 |
| minLen(len, msg)          | {{min}}         | 字符串长度是否低于最小值，即`str.length >= min`，若超则返回验证消息 |
| rangeLen([min, max], msg) | {{min}} {{max}} | 字符串长度是否在范围内，若不在则返回验证消息                 |
| len(len, msg)             | {{len}}         | 字符串长度是否为固定值，若不是则返回验证消息                 |
| enum(list, msg)           | {{list}}        | 字符串是否在枚举值中，若不在则返回验证消息                   |
| prefix(txt, msg)          | {{txt}}         | 字符串是否包含前缀，若不包含则返回验证消息                   |
| suffix(txt, msg)          | {{txt}}         | 字符串是否包含后缀，若不包含则返回验证消息                   |
| include(txt, msg)         | {{txt}}         | 字符串是否包含给定字符串，若不包含则返回验证消息             |
| exclude(txt, msg)         | {{txt}}         | 字符串是否排除在给定字符串中，若不排除则返回验证消息         |
| unique(msg)               |                 | 字符串是否包含不重复的字符，若不包含则返回验证消息           |
| within(list, msg)         | {{list}}        | 字符串是否包含列表中的字符串，若不包含则返回验证消息         |
| without(list, msg)        | {{list}}        | 字符串是否排除列表中的字符串，若不排除则返回验证消息         |
| pattern(pattern, msg)     | {{pattern}}     | 字符串自定义正则表达式验证，若验证不通过返回验证消息         |
| includeZh(msg)            |                 | 字符串是否包含中文， 若不包含返回验证消息                    |
| onlyZh(msg)               |                 | 字符串是否只包含中文，若不全是中文返回验证消息               |
| excludeZh(msg)            |                 | 字符串是否排除中文，若不排除则返回验证消息                   |
| maybeDByte(msg)           |                 | 字符串是否都是双字节字符，若不是则返回验证消息               |

> 注入： 注入参数即为模板字符串，例如`$v.maxLen(10, '最大值不能超过{{max}}')`，消息`msg`参数中可以写入类似于`{{xxx}}`的模版变量，反向注入配置参数，让消息提示更加具体化和自适应性。（后面有关注入参数的以概如此）

### 数字验证

| 方法                   | 注入参数        | 功能说明                                                     |
| ---------------------- | --------------- | ------------------------------------------------------------ |
| max(max, msg)          | {{max}}         | 数字是否小于等于最大值，若不则返回验证消息                   |
| min(min, msg)          | {{min}}         | 数字是否大于等于最小值，若不则返回验证消息                   |
| lte(max, msg)          | {{max}}         | 数字是否小雨等于最大值，若不则返回验证消息，方法同`max`      |
| gte(min, msg)          | {{min}}         | 数字是否大于等于最小值，若不则返回验证消息，方法同`min`      |
| lt(max, msg)           | {{max}}         | 数字是否小于最大值，若不则返回验证消                         |
| gt(min, msg)           | {{min}}         | 数字是否大于最小值，若不则返回验证消息                       |
| eq(value, msg)         | {{value}}       | 数字是否等于预设值，若不则返回验证消息                       |
| ne(value, msg)         | {{value}}       | 数字是否不等于预设值，若相等则返回验证消息                   |
| range([min, max], msg) | {{min}} {{max}} | 数字是否在预设范围内（min ≤ value ≤ max），若不在则返回验证消息 |
| gtlt([min, max], msg)  | {{min}} {{max}} | 数字是否在预设范围内（min < value < max），若不在则返回验证消息 |
| lgte([min, max], msg)  | {{min}} {{max}} | 数字是否在预设范围内（min ≤ value < max），若不在则返回验证消息 |
| glte([min, max], msg)  | {{min}} {{max}} | 数字是否在预设范围内（min < value ≤ max），若不在则返回验证消息 |
| divisible(value, msg)  | {{value}}       | 数字是否能被预设数值整除，若不能则返回验证消息               |

### 类型验证

| 方法       | 注入参数 | 功能说明                                   |
| ---------- | -------- | ------------------------------------------ |
| int(msg)   |          | 输入项是否整数，若不则返回验证消息         |
| float(msg) |          | 输入项是否小数，若不则返回验证消息         |
| email(msg) |          | 输入项是否邮箱格式，若不则返回验证消息     |
| url(msg)   |          | 输入项是否连接地址格式，若不则返回验证消息 |
| hex(msg)   |          | 输入项是否十六进制格式，若不则返回验证消息 |
| ip4(msg)   |          | 输入项是否ip4，若不则返回验证消息          |
| color(msg) |          | 输入项是否验证格式，若不则返回验证消息     |



### 其他验证

| 方法                                    | 注入参数 | 功能说明                                         |
| --------------------------------------- | -------- | ------------------------------------------------ |
| required(msg)                           |          | 判断字段是否不为空，若为空则返回验证消息  |
| custom(fn, msg)                         |          | 判断输入项目是否满足函数验证，若不则返回验证消息，参考[async-validator](https://github.com/yiminghe/async-validator#validator) |
| remote({ url, query, success, callback, trigger}) | {{value}} | 判断输入项目是否满足远程验证，若不则返回验证消息 |

远程验证`remote`的参数如下：

- url - 验证地址（发起get请求）
- query - 验证参数对象
- validate - 异步验证回调函数，函数中能拿到服务端传回的数据（`response.body.data`）
- callback - 回调函数，该回调函数发生在向服务端发起请求之后，无论是否成功，都将触发
- trigger - 触发方式，默认为`blur`，可选值`change`，不建议修改

远程验证时，向服务端发起验证的请求和整个平台的请求是一致的，`response.body`的返回结果一定`{data, code, msg}`，并且都会对`code`做拦截处理。如果成功返回了正确的结果，都会在`validate`函数中捕获到，反之错误信息会在内部通过`asyncValidator.callback`的方式返回给视图，作为开发者不需要拿到错误信息。最后，如果你还有什么其他的时间要处理，可以在`callback`中定义`finally`回调。

总结一下：整个的过程是一个`Promise`，成功后可再次使用`validate`对服务端返回数据进行本地校验。如果服务端返回错误，内部会自行`reject`，但都会执行一次`finally`，开发者通过`callback`定义最终执行函数即可。

### 业务验证

| 方法          | 注入参数 | 功能说明                                                 |
| ------------- | -------- | -------------------------------------------------------- |
| idcard(msg)   |          | 判断输入项是否身份证格式，若不则返回验证消息             |
| phone(msg)    |          | 判断输入项是否手机格式，若不则返回验证消息               |
| mobile(msg)   |          | 判断输入项是否电话格式，若不则返回验证消息               |
| username(msg) |          | 判断输入项是否满足用户名要求输入格式，若不则返回验证消息 |
| password(msg) |          | 判断输入项是否满足密码要求输入格式，若不则返回验证消息   |

> 注意：业务验证是会随着业务变化发生调整的，内置的都是默认规则。
>
> 默认规则为：
> 1. idcard - `/^[1-9]\d{5}(18|19|20|(3\d))\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/`
> 2. phone - `/^(\+\d{2}-)?(\d{2,3}-)?([1][3,4,5,7,8][0-9]\d{8})$/`
> 3. mobile - `/^(\+\d{2}-)?0\d{2,3}-\d{7,8}$/`
> 4. username - `/^[a-zA-Z0-9~!@#$%^&*]{8,16}$/`
> 5. password - `/^[a-zA-Z0-9~!@#$%^&*]{6,20}$/`
>
> 你可以在`~/config.js`文件中修改他们，并且拓展自己的业务验证
>
> ```javascript
> {
>   VALIDATION: {
>     idcard: /^\S$/,
>     phone: /^\S$/,
>     mobile: /^\S$/,
>     username: /^\S$/,
>     password: /^\S$/,
>     // 拓展验证规则
>     vin: /^\S$/,
>   }
> }
> ```

## 迁移意见

`@mix/form-record.js`和`@mix/form-record-mix.js`仍然保留，但不再做维护，是今后一定会弃用的混入器。你可以选择继续使用，但要注意他无法保证表单可进行实时验证，你仍可以根据项目本身的进度进行替换成现有的方案。替换时需要注意：

1. `a-form`和`a-form-item`都要替换成`a-form-model`和`a-form-model-item`；
2. `form`组件中不再使用`v-decorator`而是使用`v-model`，并且`v-model`必须填写属性的完整路径，例如`v-model="record.createTime"`；
3. 表单的验证的`API`也发生变更了，以前是`form.validate(err => {})`，现在是`form.validate(valid => valid)`，注意，回调函数必须返回`valid`，这个会交给`form`进行视图上错误信息的反馈；
4. 验证信息也不再配置在`v-decorator`内，而是配置在`a-form-model-item`中，具体的请参考[官方API文档](https://www.antdv.com/components/form-model-cn/#components-form-model-demo-validation)；