import { Story, Preview, Meta, Props } from '@storybook/addon-docs/blocks';

<Meta title="框架|核心（Core）/状态树（Store）" />

## 状态树

[Vuex](https://vuex.vuejs.org/zh) 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。

有关`Vuex`的相关内容，在[官方文档](https://vuex.vuejs.org/zh)中都有详细的描述，这里不做再次的描述了。`vsee`框架中内置了`Vuex`，并对`Vuex`的加载进行了工程化改造。至于你想不想用它，完全取决于你项目的实际用途和开发模式。我们将**状态树**进行了精分，分为：

1. root state（根状态）;
2. module state（模块状态）;

下面我们将进行详细叙述：

## 根状态 - Root State

`vsee`框架默认提供的最顶层的状态树，是全局共享的。框架按照它的使用场景，分成了如下几类：

### 授权状态 - Auth

主要负责存储登陆信息和授权功能，所拥有的方法签名如下：

```json
{
  state: {
    // 是否包含登陆模块（模块是否包含登录，由模块中的登录文件自动生成）
    allowLogin: Boolean,
    // 是否已经登录过
    isLogin: Boolean,
    // UUID
    uuid: String,
    // 令牌信息
    token: String,
  },
  getters: {
    /**
     * 判断是否为登录状态
     * @return Boolean
     */ 
    isLogin () {},
    /**
     * 获取用户登录的缓存信息
     * @return Object
     */ 
    getLoginCache () {},
    /**
     * 获取当前系统的UUID
     * @return String
     */ 
    getUUID () {},
    /**
     * 获取当前系统的令牌信息
     * @return String
     */ 
    getToken () {},
  },
  mutations: {
    /**
     * 设置登录状态
     * @params String token - 设置的TOKEN信息，如果存在则存储Cookie，否则清除Cookie，重置为非登录状态
     */ 
    setLoginStatus (token) {},
    /**
     * 设置令牌信息，setLoginStatus的同名方法
     * @params String token - 设置的TOKEN信息，如果存在则存储Cookie，否则清除Cookie，重置为非登录状态
     */ 
    setToken (token) {},
    /**
     * 缓存用户登录信息，即记住用户名密码功能，该功能对数据进行了加密处理
     * @params Object userInfo - 用户的登录信息，包含用户名和密码
     */ 
    cacheLoginInfo (userInfo) {},
    /**
     * 清除用户登录信息
     */ 
    cleanLoginInfo () {},
    /**
     * 设置新的UUID，无需任何参数，系统自动运算得到新的UUID
     */ 
    setUUID () {},
  },
  actions: {
    /**
     * 登录接口
     * 1. 需要config.js文件配置了登录接口才可启用成功
     * 2. config.js文件还可以设置是否自动处理登录，如果设置自动处理，将会刷新页面进入主界面，否则一直停留在登录入口处
     * @params Object loginInfo - 设置的TOKEN信息，如果存在则存储Cookie，否则清除Cookie，重置为非登录状态
     * @return Object - 登录成功后的信息
     */ 
    login (loginInfo) {},
    /**
     * 登出接口
     * 1. 需要config.js文件配置了登出接口才可启用成功
     * 2. 无论当前是否登出状态，都会强制登出并跳转到首页
     */ 
    logout () {},
    /**
     * 加载新的UUID
     */
    loadUUID () {}
  },
}
```

### 应用信息 - App

应用信息主要存储包括**系统信息**、**用户信息**、**系统配置信息**、**菜单信息**、**权限信息**、**工作流信息**等。在`vsee`中全部都是分开定义再进行汇总的，所拥有的方法签名如下：

#### 系统配置信息 - Config

```json
{
  state: {
    // 系统配置信息，可以存储和系统配置相关联的全部信息
    config: Object,
  },
  getters: {
    /**
     * 获取系统配置信息
     * @return Object - 返回系统配置信息
     */
    getConfig () {} 
  },
  mutataions: {
    /**
     * 设置系统配置信息
     * @params Object configInfo - 系统配置信息对象
     */ 
    setConfig (configInfo) {}
  }
}
```

#### 菜单信息 - Menu

```json
{
  state: {
    // 菜单信息，存储服务端菜单
    menus: Array<Object>,
    // 路由信息，存储客户端路由
    routers: Array<Object>,
  },
  getters: {
    /**
     * 获取服务端菜单信息
     * @return Array<Object> - 返回服务端菜单信息
     */
    getMenus () {},
  },
  mutataions: {
    /**
     * 设置服务端菜单信息
     * @params Array<Object> menus - 服务端菜单信息
     */ 
    setMenus (menus) {},
    /**
     * 设置客户端路由信息
     * @params Array<Object> routers - 客户端菜单信息
     */ 
    setRouters (routers) {}
  }
}
```

### 页面信息 - Page

页面信息用于控制页面的刷新、跳转、回到首页等功能，特别是**跳转**功能，不同的系统跳转的首页可能是不一样的没，都是统一通过`store`进行计算和判断之后再跳转的，

```json
{
  state: {
    // 内容区域（又或者叫中心区域，或者英雄区域）的刷新控制，内容区域一般放小页面
    refresh: Boolean,
    // 非内容区域的刷新控制，非内容区域都是全局的菜单、用户信息、通知、消息等
    reload: Boolean,
  },
  mutations: {
    /**
     * 设置内容区域刷新状态
     * @params Boolean refresh - 是否刷新
     */ 
    setRefresh (refresh) {},
    /**
     * 设置非内容区域刷新状态
     * @params Boolean reload - 是否刷新
     */ 
    setReload (reload) {},
  },
  actions: {
    /**
     * 内容区域刷新，内部会在组件更新完毕之后自动刷新页面
     */ 
    refresh () {},
    /**
     * 非内容区域刷新，内部会在组件更新完毕之后自动刷新页面
     */ 
    reload () {},
    /**
     * 跳转到首页
     */ 
    gohome () {},
  }
}
```

### 语言信息 - Language

用于控制内部国际化的，由于语言信息关联的点非常的多，统一的都是在这个模块下处理，目前已知的需要国际化处理的包含`vue-i18n`、`ant-design-vue`和`moment`，未来增加其他类型时，也都是在唯一的一个地方处理。

```json
{
  state: {
    // 语言信息描述，即语言，是一个符合PrimaryTag-SubTag的标准格式，例如`zh-CN`
    language: String,
    // 本地信息描述，即语系，是一个符合PrimaryTag的标准格式，例如`zh`
    local: String,
  },
  getters: {
    /**
     * 获取当前系统语言，例如`zh-CN`
     * @return String - 返回当前系统语言，例如`zh-CN`
     */ 
    getLanguage () {},
    /**
     * 获取当前系统语系，例如`zh`
     * @return String - 返回当前系统语系，例如`zh`
     */ 
    getLocal () {},
  },
  mutations: {
    /**
     * 设置当前系统语言
     * @params String language - 设置的语言，例如`zh-CN`
     */ 
    setLanguage (language) {},
    /**
     * 设置当前系统语系
     * @params String local - 设置的语系，例如`zh`
     */ 
    setLocal (local) {}
  },
  actions: {
    /**
     * 载入语言环境，会自动将几种库的语言进行统一设定，例如`vue-i18n`、`ant-design-vue`和`moment`
     * @params String language - 设置的语言，例如`zh-CN`
     */ 
    loadLanguage (language) {}
  }
}
```

### 环境 Dev

用户标识不同环境的状态树，某些时候，需要知道不同环境的环境信息，进行url地址拼接，或者其他处理。

```json
{
  state: {
    // 是否处于数据模拟阶段
    isMock: Boolean,
    // 是否是生产阶段（sit、uat或者prod都属于生产模式）
    isProd: Boolean,
    // 是否是开发阶段
    isDev: Boolean,
    // 是否调试模式
    isDebug: Boolean,
    // 是否构建测试模式（sit、uat都是构建测试模式），也可称之为生产测试模式
    isBuildTest: Boolean,
  },
  getters: {
    /**
     * 是否处于数据模拟阶段
     * @return Boolean - 是否处于数据模拟阶段
     */ 
    isMock () {},
    /**
     * 是否是生产阶段
     * @return Boolean - 是否是生产阶段
     */ 
    isProd () {},
    /**
     * 是否是开发阶段
     * @return Boolean - 是否是开发阶段
     */ 
    isDev () {},
    /**
     * 获取对应环境的绝对链接地址
     * @params String url - 相对链接地址
     * @return String - 真实的绝对链接地址
     */ 
    getUrl (url) {},
    /**
     * 构建模式
     * @return String - 构建测试模式名称（sit、uat或者prod）
     */ 
    buldType () {},
  },
  mutations: {
    /**
     * 切换模拟模式（true - 模拟模式，模式模式下会自动加载mock服务，false - 代理模式，代理模式下会代理到后端服务器中获取数据）
     * @params Boolean flag - 调试模式
     */ 
    debug (flag) {},
    /**
     * 更新`root state`的方式，传入函数中可以直接获取当前`root state`，可直接进行修改维护；
     */
    update (state, fn) {},
  }
}
```

### 其他信息

配置在`config.GLOBAL_API_LIST`下的参数，可以生成全局的状态，假设配置如下：

```javascript
GLOBAL_API_LIST: {
  key: [url, args, def]
}
```

则生成如下状态树：

```javascript
{
  state: {
    [${key}]: ${def},
  },
  getters: {
    [is${Key}Loaded]: false,
    [get${Key}LOaded}]: () => {},
  },
  mutations: {
    [set${Key}]: () => {},
  },
  actions: {
    [fetch${Key}]: () => {},
  }
}
```

当你想要增加外部的全局接口的时候，就可以这样去处理。

## 模块状态

`vsee`框架中内置了模块状态的处理机制，首先我们要了解，模块状态是如何加载进去的。

项目是包含多个模块的（`module`），这些模块中，如果包含有`store/index.js`文件，则会将其加载为一个模块，自动挂载到整个项目中。每个开发人员管理自己的模块时，只需要处理自己模块的数据信息和方法即可。但如果需要进行跨模块访问，也是可以的，但最好不要这么做，除非你知道这样做是必然的。因为状态树是唯一的，所以可以彼此模块之间进行相互访问。模块的状态树是每个开发人员自定义的，但`vsee`框架仍然为每个`module store`增加了内部方法：

```json
{
  // 开发人员自定义模块的状态树数据
  state: { ... },
  // 强制内嵌的状态树方法，包括getters和mutations
  getters: {
    /**
     * 获取模块状态树
     * @return Object - 返回模块级的状态树的全部数据
     */ 
    init () {}
  },
  mutations: {
    /**
     * 还原状态树，并设置新属性
     * 1. 还原时，会先还原全部属性，再设置属性
     * 2. 设置的数据如果未出现在state的定义中，则不设置该属性
     * @params Object payload - 填充对象
     */ 
    init (state, payload) {},
    /**
     * 设置状态树
     * 1. 设置时，仅设置当前属性，不修改其他属性；
     * 2. 修改的数据如果未出现在state的定义中，则不修改该属性
     * @params Object payload - 设置对象
     */ 
    set (state, payload) {},
    /**
     * 自定义更新
     * 更新函数中将获取当前模块的`state`；
     * 更新函数的`this`会指向当前模块的`module store`；
     */
    update (state, fn) {},
  }
}
```