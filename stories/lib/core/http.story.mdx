import { Story, Preview, Meta, Props } from '@storybook/addon-docs/blocks';

<Meta title="框架/核心（Core）/网络请求（http）" />

# 网络请求

我们将所有的资源请求都封装成一个`@http`模块，这是一个对`axios`的封装。

在网络请求器内部，我们有多套`axios`的实例，例如：

- core - 对接主业务服务的资源请求器；
- mock - 对接模拟数据的网络请求器；
- proxy - 对接其他代理服务器，该代理无任何主业务特性，可用于请求外部数据；
- static - 对接静态资源服务的下载器；
- download - 对接业务主服务的下载器，该下载器是`core`的拓展实例；

但作为开发者并不需要知道这些。而是直接使用公开的方法去调用即可。

## 请求规范

请求方式完全参考`RESTFUL`的设计思路。其中，请求头的会附带如下字段：

```javascript
/* 缓存策略 */
'Cache-Control': 'no-cache,no-store,must-revalidate,max-age=0,no-siteapp,post-check=0,pre-check=0',
Pragma: 'no-cache',
/* ${HTTP_HEADER} */
token: '',                    // token信息
Authorization: '',            // 授权信息
'Accept-Language': 'zh-CN',   // 语言环境
```

注意，以上是默认的设置，其中你可以使用`config.HTTP_HEADER`覆盖或者增加额外的请求头，但`token`、`Authorization`、`Accept-Language`信息是由系统所为维护的，没有任何入口去进行维护，并且我们也不希望你去维护。

## 响应规范

见下方【[错误处理](#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86)】，响应的数据结构一定包含`code`和`data`，如果`code`不为`0`，则还应该包含错误信息`msg`。对于登录接口来说，`token`信息都是放在`data`中的，前端在捕获到登录接口之后会自动识别`token`，并将`token`设置到今后请求的请求头中。

## 引入方式

我们为`http`模块统一了引入入口，使用如下代码引入：

```javascript
import $ from '@http';
```

这里我们使用`$`来定义引入的对象，让人感觉是对`jQuery`的致敬与怀旧。接着我们就可以直接使用`$`来按照`RESTFUL`风格请求接口了。

## 请求接口

我们按照`RESTFUL`风格对`axios`进行了相关的封装，结合类似`jQuery`的使用方式，封装出如下的API：

```javascript
const $ = {
  /**
   * axios.core实例
   * 使用`GET`方式提交数据请求
   * @param {String} url - 请求地址
   * @param {*} params - `query`参数
   * @param {Object} config - 请求配置，参考http://www.axios-js.com/zh-cn/docs/#%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE
   */ 
  get (url, params, config) {},
  /**
   * axios.core实例
   * 使用`DELETE`方式提交数据请求
   * @param {String} url - 请求地址
   * @param {*} params - `query`参数
   * @param {Object} config - 请求配置，参考http://www.axios-js.com/zh-cn/docs/#%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE
   */ 
  delete (url, params, config) {},
  /**
   * axios.core实例
   * 使用`HEAD`方式提交数据请求
   * @param {String} url - 请求地址
   * @param {*} params - `query`参数
   * @param {Object} config - 请求配置，参考http://www.axios-js.com/zh-cn/docs/#%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE
   */ 
  head (url, params, config) {},
  /**
   * axios.core实例
   * 使用`POST`方式提交数据请求
   * @param {String} url - 请求地址
   * @param {*} data - `body`参数
   * @param {Object} config - 请求配置，参考http://www.axios-js.com/zh-cn/docs/#%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE
   */ 
  post (url, data, config) {},
  /**
   * axios.core实例
   * 使用`PUT`方式提交数据请求
   * @param {String} url - 请求地址
   * @param {*} data - `body`参数
   * @param {Object} config - 请求配置，参考http://www.axios-js.com/zh-cn/docs/#%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE
   */ 
  put (url, data, config) {},
  /**
   * axios.core实例
   * 使用`PATCH`方式提交数据请求
   * @param {String} url - 请求地址
   * @param {*} data - `body`参数
   * @param {Object} config - 请求配置，参考http://www.axios-js.com/zh-cn/docs/#%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE
   */ 
  patch (url, data, config) {},
  /**
   * axios.core实例
   * 使用`OPTIONS`方式提交数据请求
   * @param {String} url - 请求地址
   * @param {*} params - `query`参数
   * @param {Object} config - 请求配置，参考http://www.axios-js.com/zh-cn/docs/#%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE
   */ 
  options (url, params, config) {},
  /**
   * axios.proxy实例
   * 使用代理进行自定义方式请求数据
   * 注意，该请求不是用来对接后台的主服务，是用来请求其他跨域或外部站点的
   * @param {Object} config - 请求配置，参考http://www.axios-js.com/zh-cn/docs/#%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE
   */ 
  request (config) {},
  /**
   * axios.proxy实例
   * 使用`jsonp`方式请求数据
   * @param {String} url - 请求地址
   * @param {*} params - `query`参数
   * @param {*} callback - 非同源资源请求的回调函数名称，默认值`callback`
   */ 
  jsonp (url, params, callback = 'callback') {},
  /**
   * axios.static实例
   * 使用静态资源的方式下载文件
   * @param {String} url - 请求地址，可以是内部站点，也可以是外部站点。如果为外部站点，请注意跨域问题。
   */
  static (url) {}, 
  /**
   * axios.download实例
   * 使用动态资源的方式下载文件，区分于`静态资源`，该服务是一个受限的内部服务。
   * @param {String} url - 请求地址
   * @param {*} params - `query`参数
   * @param {*} config - 额外的配置，其结构为`{
   *    filename: '文件名称', // 文件名称
   *    nameCallback: name => `preifx_${name}`, // 文件名称函数
   *    headers: {}, // 请求头
   *    method: 'POST, // 请求方式
   * }`
   */ 
  download (url, params, config) {}
}
```

## 代理模式

`@http`模块有两种数据请求模式，一种是正常请求模式，一种是代理模式。代理模式都是使用在`mock`场景下的。如下两种场景会使用代理模式：

```bash
npm run dev --project=idm               // 开发环境下启用代理模式来请求模拟数据
npm run build:sit --project=idm --test  // 生产环境下启用代理模式来请求模拟数据
```

代理模式下，请求接口会被`mock`模块拦截，也就是被所有模块下的`mock`文件下的`js`文件对应的模拟请求所拦截，不会发起真正的请求，而直接响应模拟的数据。

## 错误处理

客户端向服务端发起请求，通常会有三种响应结果：

1. 客户端或网络异常，客户端请求未达服务端，会生成一个前端的`HTTPResponse`；
2. 客户端抵达服务端，但服务端未正常使用服务处理，返回服务器返回的`HTTPResponse`；
3. 服务端正常接受并处理业务，但有业务问题，返回服务器返回的`HTTPResponse`；

前两者中，错误信息是包装在`HTTPRequest.status`中的，对于第三种，业务错误信息则是包装在`HTTPResponse.body`中的，而根据业务需求，响应体的格式为：

```json
{
  "code": 0,  // 如果不为0，则为业务错误，错误信息查看`msg`
  "data": {}, // 如果成功则返回业务数据
  "msg": '',  // 如果不成功，则返回业务错误信息 
}
```

因此，我们统一对`HTTPResponse`的响应错误进行了处理：

1. 请求成功 - 表示服务端正确返回且不包含业务错误，则将业务数据传递给上层组件；
2. 请求失败 - 服务端未正确返回，或返回响应体中包含错误信息，则自动识别错误状态码，传递给上层组件；

传递的错误状态码都是编码格式，包含有`HTTP Status`的`200`、`404`、`500`，也包含有业务状态码的`100004`(用户名密码错误)、`100010`(用户账号已过期)。如果服务端返回数据中不包含`msg`字段，则直接上报错误状态码，然后由开发人员做前端国际化或者处理，否则，会自动弹出信息提示。

> 注意，响应结构体中的`code`是必传的，否则前端都会当做是一种错误来捕获，且错误信息是**未定义**。

## 数据处理

我们对请求成功的数据，也做了进一步处理：

1. 如果响应数据为`Blob`，自动实现下载，并返回文件名（已经废除，改为开发者自行调用`$.download`进行下载）；
2. 如果响应数据为二进制，则返回二进制数据供前端展现（例如服务端验证码）；
3. 如果响应数据中`code`为`401`，则在生产环境下直接跳转到登录页；
4. 如果响应数据为合法数据，则直接传递给上层组件；否则异常处理；

## 其他

我们还为`axios`添加了一些额外的校验和功能：

1. 代理模式下，会自动添加日志模块。由于代理模式下`http`请求是无法正常发出，只能被拦截，因此控制台上是无法查阅到对应的请求信息，只能通过日志模块来查看；
2. 如果包含登录模块，则登录模块的会被拦截请求数据，并将`token`信息注入到今后的所有资源请求中；
3. 请求前检测`token`，如果没有，则退出系统并跳转到登录模块；

## 公开配置

我们为`@http`公开了部分配置，你可以在`~/config.js`文件中追加，配置内容如下：

```javascript
/**
 * 网络相关配置
 */
HTTP: {
  /**
   * 超时时间，默认值`6000`
   */ 
  TIMEOUT: 6000,
  /**
   * 附加请求头，默认值`{}`；
   * 注意，附加请求头不代表会替换所有请求头内容，有一部分的请求头内容是计算之后得到的，无法覆盖；
   */ 
  HEADER: {},
  /**
   * 主代理，用于切换到其他代理服务器上进行代理联调
   */ 
  PROXY: null,
  /**
   * GET请求的附加参数，例如可以增加统一的时间戳
   * 默认值`{}`
   */ 
  GET_PARAMS: {},
  /**
   * 是否开启模拟日志，默认`true`
   */ 
  MOCK_LOG: true,
  /**
   * 重连地址，如果主连接无法连接，会尝试使用`RETRY_LIST`所配置列表进行连接
   */ 
  RETRY_LIST: [],
  /**
   * `params`参数格式化，这是应用在`get`、`delete`请求中的。
   * 默认值`{}`
   */ 
  PARAMS_SERIALIZER: {},
  /**
   * `axios`的注入函数，用于配置额外的注入
   */ 
  INTERCEPTORS: {},
}
```

其中`INTERCEPTORS`配置案例为：

```javascript
INTERCEPTORS: {
  request (req) {
    req.headers.xxx = 'xxx';
  },
  response (res) {
    res.headers.yyy = 'yyy';
  }
}
```

## feature

- [ ] 下载兼容性（考虑接入`FileSaver.js`源码思路）
- [x] 文件下载（静态下载、外域资源下载）
- [x] 请求重连（已完成未配置）
- [x] 公开更多配置





