import { Story, Preview, Meta, Props } from '@storybook/addon-docs/blocks';
import NetSelect from '@comp/form/NetSelect.vue';
import { mapPropsToFields, autoUpdateFileds } from '@util/formhelper.js';
import { keyMapFrom, transform } from '@util/datahelper.js';

<Meta title="组件库|Form表单/NetSelect网络下拉框" />

# 网络下拉框 NetSelect

> 继承：Ant Design Vue [Select](https://www.antdv.com/components/select-cn/)

> 混入：[]

> 排除属性： ['options', 'label-in-value']

> 拓展属性： ['closeSearch', 'url', 'query', 'delay', 'cache', 'transform'] 见下方


<Props of={ NetSelect } />

## 案例

### 原生写法

按照**AntD**原生所提供的写法，基本能满足日常开发需求，但是会有几个复杂的问题，基本上是处理数据以及内部变量的问题。我们可以先来看看原生写法所提供的，再来讲讲开发上存在的问题：

<Preview withToolbar>
<Story name="基础">
{{
  template: `
    <div>
      下拉列表：
      <a-select
        style="width: 100%"
        placeholder="请选择"
        :options="options"
      />
    </div>
  `,
  data () {
    return {
      options: [
        { value: '10001', label: '选项1' },
        { value: '10002', label: '选项2' }
      ]
    }
  }
}}
</Story>
</Preview>

> 【问题分析】
>
> 虽然**AntD**上的`select`组件在官网的API中给的非常的详尽，用法也非常的多。但如果不进行加工就直接给开发人员，中间会有很多复杂的地方以及交互上的瑕疵。比如：
>
> 1. 下拉的数据往往是通过异步数据获取的，内部没有封装`fetch`数据的方式；
> 2. 下拉数据过程中，状态的变化需要用很多的变量来去控制，而且基本上是重复控制；
> 3. 下拉数据的回显往往会出现**一闪**的情况，因此下拉获取的`value`值和`options`值不能确保同步；
> 4. 没有增加业务上的策略，例如**缓存**、**延迟**等策略，加入这些策略对丰富应用非常有帮助；

### 网络加载

仅仅配置一个`url`地址，即可完成数据加载。但有一个前提，服务端提供的数据格式必须是`{ value, label }`或`{ key, label }`的格式。在数据有延迟的情况下，不会影响交互。

<Preview withToolbar>
<Story name="网络加载">
{{
  template: `
    <div>
      网络下拉列表：
      <net-select
        style="width: 100%"
        placeholder="请选择"
        url="/net-select/base"
      />
      网络下拉列表（延迟数据加载）：
      <net-select
        style="width: 100%"
        placeholder="请选择"
        url="/net-select/timeout"
      />
    </div>
  `
}}
</Story>
</Preview>

### 延迟加载

根据下拉选框的使用频率，可以设定一种加载机制，一种是展示组件时立刻加载数据，另一种是点击下拉后再加载数据（delay），后者就是我们给定的参数`delay`策略。`delay`默认是开启的，如果希望组件创建时就立刻加载数据，可以关闭此项。

<Preview withToolbar>
<Story name="延迟策略">
{{
  template: `
    <div>
      网络下拉列表（默认延迟加载，即点击下拉按钮才发起数据请求）：
      <net-select
        style="width: 100%"
        placeholder="请选择"
        url="/net-select/base"
      />
      网络下拉列表（取消延迟加载，组件加载状态中立即发起数据请求）：
      <net-select
        style="width: 100%"
        placeholder="请选择"
        url="/net-select/base"
        :delay="false"
      />
    </div>
  `
}}
</Story>
</Preview>

### 缓存数据

根据下拉数据的更新频率，我们又可以定义新的策略。有的数据列表更新频率高，因此每次下拉的时候都应该重新获取新的数据，有的数据列表更新频率极低，因此可以将数据缓存起来。`net-select`默认开启`cache`缓存策略，以减少网络资源的获取，如果你觉得有需要关闭，可自行配置。

<Preview withToolbar>
<Story name="缓存策略">
{{
  template: `
    <div>
      网络下拉列表（缓存下拉数据，重复点击下拉时，不刷新数据）：
      <net-select
        style="width: 100%"
        placeholder="请选择"
        url="/net-select/base"
      />
      网络下拉列表（取消缓存策略，每次点击下拉时，重新获取最新数据）：
      <net-select
        style="width: 100%"
        placeholder="请选择"
        url="/net-select/uncache"
        :cache="false"
      />
    </div>
  `
}}
</Story>
</Preview>

### 数据转换

`net-select`接受形如`{ key/value, label }`样式的数据，如果服务端发送的是原始数据，或者跟`net-select`定义的数据结构不一致，将导致数据无法挂载到组件上。`net-select`内置了`transform`函数，默认为`id组合子`，你也可以指定一个新的转换函数。例如本例子中，服务端返回数据结构为`{ id, name }`：

<Preview withToolbar>
<Story name="转换策略">
{{
  template: `
    <div>
      网络下拉列表（下拉数据经过转换函数转换后渲染）：
      <net-select
        style="width: 100%"
        placeholder="请选择"
        url="/net-select/transform"
        :transform="transform"
      />
    </div>
  `,
  methods: {
    transform (list) {
      return list.map(item => ({value: item.id, label: item.name}))
    }
  }
}}
</Story>
</Preview>

### 请求参数

`get`请求数据时，是可以附加参数的，参数是挂载在`query`配置项中的，其格式有两种：

- 直接键值对，例如：`{ orderFiled: 'name' }`，同`get`请求的**param**参数一致，但是是一种固定参数；
- 映射键值对，例如：`{ id: '${value}', text: '${search}'`，指定查询参数`id`为组件内的`value`参数，指定`text`为组件内的`search`参数。

映射键值对主要是处理`get`请求中的变参，例如根据`id`进行回显示，或者根据`text`进行搜索，通过这一个配置，即可完成。**注意，如果开启`${search}`，则默认会有输入框进行输入，以供用户进行筛选。我们提供了两种筛选模式，后续会有提到**

<Preview withToolbar>
<Story name="请求参数">
{{
  template: `
    <div style="height: 300px;">
      网络下拉列表（根据id进行回显，但不会加载全部数据，回显数据时会有延时特效）：
      <net-select
        value="10001"
        style="width: 100%"
        placeholder="请选择"
        url="/net-select/query"
        :query="{ id: '$\{value\}', orderFiled: 'name' }"
      />
    </div>
  `
}}
</Story>
</Preview>

### 查询参数

接上，查询参数`${search}`是配置在`query`中的，例如：

<Preview withToolbar>
<Story name="远程搜索">
{{
  template: `
    <div style="height: 300px;">
      网络下拉列表（根据text输入文本进行远程搜索）：
      <net-select
        style="width: 100%"
        placeholder="请选择"
        url="/net-select/query"
        :query="{ text: '$\{search\}', orderFiled: 'name' }"
      />
    </div>
  `
}}
</Story>
</Preview>

### 本地查询

接上，如果`query`配置了，但是未配置`${search}`，即不会打开远程搜索，进而启用本地搜索:

<Preview withToolbar>
<Story name="本地搜索">
{{
  template: `
    <div style="height: 300px;">
      网络下拉列表（根据text输入文本进行本地搜索）：
      <net-select
        style="width: 100%"
        placeholder="请选择"
        url="/net-select/query"
        :query="{ orderFiled: 'name' }"
      />
    </div>
  `
}}
</Story>
</Preview>

### 关闭搜索

如果连本地搜索都不希望启用，可以开启禁用搜索`closeSearch`选项：

<Preview withToolbar>
<Story name="关闭搜索">
{{
  template: `
    <div style="height: 300px;">
      网络下拉列表（已禁止搜索）：
      <net-select
        style="width: 100%"
        placeholder="请选择"
        url="/net-select/query"
        closeSearch
        :query="{ orderFiled: 'name' }"
      />
    </div>
  `
}}
</Story>
</Preview>

### 配合表单

`net-select`已经按照`AntD`的风格编写，可以配合表单使用：

<Preview withToolbar>
<Story name="配合表单">
{{
  template: `
    <a-form :form="form" style="height: 300px;">
      <a-form-item
        label="网络下拉选框"
        self-update
      >
        <net-select
          v-decorator="['select']"
          style="width: 100%"
          placeholder="请选择"
          url="/net-select/query"
          :query="{ orderFiled: 'name' }"
        />
      </a-form-item>
      <a-button @click="print" block>
        打印结果
      </a-button>
    </a-form>
  `,
  data () {
    return {
      record: {},
      form: null
    }
  },
  created () {
    this.mapPropsToFields = mapPropsToFields(this, ['select'], 'record');
    this.form = this.$form.createForm(this, {
      mapPropsToFields: this.mapPropsToFields,
      onValuesChange: autoUpdateFileds(this, 'record')
    });
  },
  methods: {
    print () {
      const values = this.form.getFieldsValue();
      this.$message.info(JSON.stringify(values));
    }
  }
}}
</Story>
</Preview>

### 数据联动

多个下拉之间出现联动，都是通过属性动方式来控制，这与组件是否封装该特性没有关系。这里给出两个种联动动思路：

<Preview withToolbar>
<Story name="数据联动">
{{
  template: `
    <a-form :form="form" style="height: 300px;">
      <a-form-item
        label="级联联动（上级数据影响下级数据）"
        self-update
      >
        <a-col :span="8">
          <net-select
            v-decorator="['level1']"
            placeholder="请选择省份"
            url="/net-select/cascader"
          />
        </a-col>
        <a-col :span="1" />
        <a-col :span="8">
          <net-select
            v-decorator="['level2']"
            placeholder="请选择区域"
            :url="\`/net-select/cascader?level1=$\{record.level1\}\`"
            :cache="false"
            :disabled="!record.level1"
          />
        </a-col>
      </a-form-item>
      <a-form-item
        label="同源联动（相同字段不同显示的联动）"
        self-update
      >
        <a-col :span="8">
          <net-select
            v-decorator="['level3']"
            placeholder="请选择省份"
            url="/net-select/cascader"
          />
        </a-col>
        <a-col :span="1" />
        <a-col :span="8">
          <net-select
            v-decorator="['level3']"
            placeholder="please select province"
            url="/net-select/cascaderen"
          />
        </a-col>
      </a-form-item>
      <a-button @click="print" block>
        打印结果
      </a-button>
    </a-form>
  `,
  data () {
    return {
      record: {
        // 做级联操作时，一定要定义字段并给字段赋予默认值，否则无法触发`Observer`
        level1: void 0,
        level2: void 0
      },
      form: null
    }
  },
  created () {
    this.mapPropsToFields = mapPropsToFields(this, ['level1', 'level2', 'level3'], 'record');
    this.form = this.$form.createForm(this, {
      mapPropsToFields: this.mapPropsToFields,
      onValuesChange: autoUpdateFileds(this, 'record')
    });
  },
  methods: {
    print () {
      const values = this.form.getFieldsValue();
      this.$message.info(JSON.stringify(values));
    }
  }
}}
</Story>
</Preview>
